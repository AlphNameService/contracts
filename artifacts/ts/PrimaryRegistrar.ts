/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
} from "@alephium/web3";
import { default as PrimaryRegistrarContractJson } from "../registrars/PrimaryRegistrar.ral.json";
import { getContractByCodeHash } from "./contracts";
import { Profile, AllStructs } from "./types";

// Custom types for the contract
export namespace PrimaryRegistrarTypes {
  export type Fields = {
    registrarOwner: Address;
    recordTemplateId: HexString;
    credentialTokenTemplateId: HexString;
    minRegistrationDuration: bigint;
    registerCost: bigint;
    durationCost: bigint;
  };

  export type State = ContractState<Fields>;

  export type NameRegisteredEvent = ContractEvent<{
    name: HexString;
    owner: Address;
    manager: Address;
    ttl: bigint;
  }>;
  export type NameRenewedEvent = ContractEvent<{
    name: HexString;
    ttl: bigint;
    owner: Address;
    manager: Address;
  }>;
  export type NameTransferEvent = ContractEvent<{
    name: HexString;
    newOwner: Address;
    newManager: Address;
    oldOwner: Address;
    oldManager: Address;
    ttl: bigint;
  }>;

  export interface CallMethodTable {
    resolveName: {
      params: CallContractParams<{ name: HexString }>;
      result: CallContractResult<HexString>;
    };
    register: {
      params: CallContractParams<{
        name: HexString;
        owner: Address;
        payer: Address;
        duration: bigint;
      }>;
      result: CallContractResult<null>;
    };
    renew: {
      params: CallContractParams<{
        name: HexString;
        payer: Address;
        duration: bigint;
      }>;
      result: CallContractResult<null>;
    };
    transfer: {
      params: CallContractParams<{
        name: HexString;
        toOwner: Address;
        toManager: Address;
      }>;
      result: CallContractResult<null>;
    };
    getCredentialTokenId: {
      params: CallContractParams<{ name: HexString }>;
      result: CallContractResult<HexString>;
    };
    mintCredentialToken: {
      params: CallContractParams<{ name: HexString; payer: Address }>;
      result: CallContractResult<null>;
    };
    burnCredentialToken: {
      params: CallContractParams<{ name: HexString; payer: Address }>;
      result: CallContractResult<null>;
    };
    purgeExpiredName: {
      params: CallContractParams<{ name: HexString }>;
      result: CallContractResult<null>;
    };
    withdraw: {
      params: CallContractParams<{ to: Address; amount: bigint }>;
      result: CallContractResult<null>;
    };
    updateRegistrarOwner: {
      params: CallContractParams<{ newOwner: Address }>;
      result: CallContractResult<null>;
    };
    updateRegisterCost: {
      params: CallContractParams<{ newRegisterCost: bigint }>;
      result: CallContractResult<null>;
    };
    updateDurationCost: {
      params: CallContractParams<{ newDurationCost: bigint }>;
      result: CallContractResult<null>;
    };
    migrate: {
      params: CallContractParams<{ newCode: HexString }>;
      result: CallContractResult<null>;
    };
    migrateWithFields: {
      params: CallContractParams<{
        newCode: HexString;
        immFieldsEncoded: HexString;
        mutFieldsEncoded: HexString;
      }>;
      result: CallContractResult<null>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };

  export interface SignExecuteMethodTable {
    resolveName: {
      params: SignExecuteContractMethodParams<{ name: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    register: {
      params: SignExecuteContractMethodParams<{
        name: HexString;
        owner: Address;
        payer: Address;
        duration: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    renew: {
      params: SignExecuteContractMethodParams<{
        name: HexString;
        payer: Address;
        duration: bigint;
      }>;
      result: SignExecuteScriptTxResult;
    };
    transfer: {
      params: SignExecuteContractMethodParams<{
        name: HexString;
        toOwner: Address;
        toManager: Address;
      }>;
      result: SignExecuteScriptTxResult;
    };
    getCredentialTokenId: {
      params: SignExecuteContractMethodParams<{ name: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    mintCredentialToken: {
      params: SignExecuteContractMethodParams<{
        name: HexString;
        payer: Address;
      }>;
      result: SignExecuteScriptTxResult;
    };
    burnCredentialToken: {
      params: SignExecuteContractMethodParams<{
        name: HexString;
        payer: Address;
      }>;
      result: SignExecuteScriptTxResult;
    };
    purgeExpiredName: {
      params: SignExecuteContractMethodParams<{ name: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    withdraw: {
      params: SignExecuteContractMethodParams<{ to: Address; amount: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    updateRegistrarOwner: {
      params: SignExecuteContractMethodParams<{ newOwner: Address }>;
      result: SignExecuteScriptTxResult;
    };
    updateRegisterCost: {
      params: SignExecuteContractMethodParams<{ newRegisterCost: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    updateDurationCost: {
      params: SignExecuteContractMethodParams<{ newDurationCost: bigint }>;
      result: SignExecuteScriptTxResult;
    };
    migrate: {
      params: SignExecuteContractMethodParams<{ newCode: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    migrateWithFields: {
      params: SignExecuteContractMethodParams<{
        newCode: HexString;
        immFieldsEncoded: HexString;
        mutFieldsEncoded: HexString;
      }>;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];
}

class Factory extends ContractFactory<
  PrimaryRegistrarInstance,
  PrimaryRegistrarTypes.Fields
> {
  encodeFields(fields: PrimaryRegistrarTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      AllStructs
    );
  }

  getInitialFieldsWithDefaultValues() {
    return this.contract.getInitialFieldsWithDefaultValues() as PrimaryRegistrarTypes.Fields;
  }

  eventIndex = { NameRegistered: 0, NameRenewed: 1, NameTransfer: 2 };
  consts = {
    ErrorCodes: {
      InvalidCaller: BigInt("0"),
      InvalidArgs: BigInt("1"),
      ExpectAssetAddress: BigInt("2"),
      NameHasBeenRegistered: BigInt("3"),
      ContractNotExists: BigInt("4"),
      NameHasExpired: BigInt("5"),
      InvalidCredentialToken: BigInt("6"),
    },
  };

  at(address: string): PrimaryRegistrarInstance {
    return new PrimaryRegistrarInstance(address);
  }

  tests = {
    resolveName: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "resolveName", params, getContractByCodeHash);
    },
    register: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; owner: Address; payer: Address; duration: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "register", params, getContractByCodeHash);
    },
    renew: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; payer: Address; duration: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "renew", params, getContractByCodeHash);
    },
    transfer: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; toOwner: Address; toManager: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "transfer", params, getContractByCodeHash);
    },
    cost: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { duration: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "cost", params, getContractByCodeHash);
    },
    getCredentialTokenPath: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; caller: Address }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getCredentialTokenPath",
        params,
        getContractByCodeHash
      );
    },
    getCredentialTokenId: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getCredentialTokenId",
        params,
        getContractByCodeHash
      );
    },
    mintCredentialToken: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; payer: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "mintCredentialToken",
        params,
        getContractByCodeHash
      );
    },
    burnCredentialToken: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString; payer: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "burnCredentialToken",
        params,
        getContractByCodeHash
      );
    },
    preRegister: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { node: HexString; currentTs: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "preRegister", params, getContractByCodeHash);
    },
    purgeExpiredName: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { name: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "purgeExpiredName",
        params,
        getContractByCodeHash
      );
    },
    withdraw: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { to: Address; amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "withdraw", params, getContractByCodeHash);
    },
    updateRegistrarOwner: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { newOwner: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "updateRegistrarOwner",
        params,
        getContractByCodeHash
      );
    },
    updateRegisterCost: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { newRegisterCost: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "updateRegisterCost",
        params,
        getContractByCodeHash
      );
    },
    updateDurationCost: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { newDurationCost: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "updateDurationCost",
        params,
        getContractByCodeHash
      );
    },
    migrate: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        { newCode: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "migrate", params, getContractByCodeHash);
    },
    migrateWithFields: async (
      params: TestContractParamsWithoutMaps<
        PrimaryRegistrarTypes.Fields,
        {
          newCode: HexString;
          immFieldsEncoded: HexString;
          mutFieldsEncoded: HexString;
        }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "migrateWithFields",
        params,
        getContractByCodeHash
      );
    },
  };
}

// Use this object to test and deploy the contract
export const PrimaryRegistrar = new Factory(
  Contract.fromJson(
    PrimaryRegistrarContractJson,
    "",
    "e902e51b9792f7dd31ac29903881979182b88ec6b1e6fc2b2961f277ac553c91",
    AllStructs
  )
);

// Use this class to interact with the blockchain
export class PrimaryRegistrarInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  async fetchState(): Promise<PrimaryRegistrarTypes.State> {
    return fetchContractState(PrimaryRegistrar, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeNameRegisteredEvent(
    options: EventSubscribeOptions<PrimaryRegistrarTypes.NameRegisteredEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      PrimaryRegistrar.contract,
      this,
      options,
      "NameRegistered",
      fromCount
    );
  }

  subscribeNameRenewedEvent(
    options: EventSubscribeOptions<PrimaryRegistrarTypes.NameRenewedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      PrimaryRegistrar.contract,
      this,
      options,
      "NameRenewed",
      fromCount
    );
  }

  subscribeNameTransferEvent(
    options: EventSubscribeOptions<PrimaryRegistrarTypes.NameTransferEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      PrimaryRegistrar.contract,
      this,
      options,
      "NameTransfer",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      | PrimaryRegistrarTypes.NameRegisteredEvent
      | PrimaryRegistrarTypes.NameRenewedEvent
      | PrimaryRegistrarTypes.NameTransferEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(
      PrimaryRegistrar.contract,
      this,
      options,
      fromCount
    );
  }

  view = {
    resolveName: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"resolveName">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"resolveName">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "resolveName",
        params,
        getContractByCodeHash
      );
    },
    register: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"register">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"register">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "register",
        params,
        getContractByCodeHash
      );
    },
    renew: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"renew">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"renew">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "renew",
        params,
        getContractByCodeHash
      );
    },
    transfer: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"transfer">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"transfer">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "transfer",
        params,
        getContractByCodeHash
      );
    },
    getCredentialTokenId: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"getCredentialTokenId">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"getCredentialTokenId">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "getCredentialTokenId",
        params,
        getContractByCodeHash
      );
    },
    mintCredentialToken: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"mintCredentialToken">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"mintCredentialToken">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "mintCredentialToken",
        params,
        getContractByCodeHash
      );
    },
    burnCredentialToken: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"burnCredentialToken">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"burnCredentialToken">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "burnCredentialToken",
        params,
        getContractByCodeHash
      );
    },
    purgeExpiredName: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"purgeExpiredName">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"purgeExpiredName">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "purgeExpiredName",
        params,
        getContractByCodeHash
      );
    },
    withdraw: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"withdraw">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"withdraw">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "withdraw",
        params,
        getContractByCodeHash
      );
    },
    updateRegistrarOwner: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"updateRegistrarOwner">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"updateRegistrarOwner">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "updateRegistrarOwner",
        params,
        getContractByCodeHash
      );
    },
    updateRegisterCost: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"updateRegisterCost">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"updateRegisterCost">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "updateRegisterCost",
        params,
        getContractByCodeHash
      );
    },
    updateDurationCost: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"updateDurationCost">
    ): Promise<
      PrimaryRegistrarTypes.CallMethodResult<"updateDurationCost">
    > => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "updateDurationCost",
        params,
        getContractByCodeHash
      );
    },
    migrate: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"migrate">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"migrate">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "migrate",
        params,
        getContractByCodeHash
      );
    },
    migrateWithFields: async (
      params: PrimaryRegistrarTypes.CallMethodParams<"migrateWithFields">
    ): Promise<PrimaryRegistrarTypes.CallMethodResult<"migrateWithFields">> => {
      return callMethod(
        PrimaryRegistrar,
        this,
        "migrateWithFields",
        params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    resolveName: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"resolveName">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"resolveName">
    > => {
      return signExecuteMethod(PrimaryRegistrar, this, "resolveName", params);
    },
    register: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"register">
    ): Promise<PrimaryRegistrarTypes.SignExecuteMethodResult<"register">> => {
      return signExecuteMethod(PrimaryRegistrar, this, "register", params);
    },
    renew: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"renew">
    ): Promise<PrimaryRegistrarTypes.SignExecuteMethodResult<"renew">> => {
      return signExecuteMethod(PrimaryRegistrar, this, "renew", params);
    },
    transfer: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"transfer">
    ): Promise<PrimaryRegistrarTypes.SignExecuteMethodResult<"transfer">> => {
      return signExecuteMethod(PrimaryRegistrar, this, "transfer", params);
    },
    getCredentialTokenId: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"getCredentialTokenId">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"getCredentialTokenId">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "getCredentialTokenId",
        params
      );
    },
    mintCredentialToken: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"mintCredentialToken">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"mintCredentialToken">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "mintCredentialToken",
        params
      );
    },
    burnCredentialToken: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"burnCredentialToken">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"burnCredentialToken">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "burnCredentialToken",
        params
      );
    },
    purgeExpiredName: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"purgeExpiredName">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"purgeExpiredName">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "purgeExpiredName",
        params
      );
    },
    withdraw: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"withdraw">
    ): Promise<PrimaryRegistrarTypes.SignExecuteMethodResult<"withdraw">> => {
      return signExecuteMethod(PrimaryRegistrar, this, "withdraw", params);
    },
    updateRegistrarOwner: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"updateRegistrarOwner">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"updateRegistrarOwner">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "updateRegistrarOwner",
        params
      );
    },
    updateRegisterCost: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"updateRegisterCost">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"updateRegisterCost">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "updateRegisterCost",
        params
      );
    },
    updateDurationCost: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"updateDurationCost">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"updateDurationCost">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "updateDurationCost",
        params
      );
    },
    migrate: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"migrate">
    ): Promise<PrimaryRegistrarTypes.SignExecuteMethodResult<"migrate">> => {
      return signExecuteMethod(PrimaryRegistrar, this, "migrate", params);
    },
    migrateWithFields: async (
      params: PrimaryRegistrarTypes.SignExecuteMethodParams<"migrateWithFields">
    ): Promise<
      PrimaryRegistrarTypes.SignExecuteMethodResult<"migrateWithFields">
    > => {
      return signExecuteMethod(
        PrimaryRegistrar,
        this,
        "migrateWithFields",
        params
      );
    },
  };

  async multicall<Calls extends PrimaryRegistrarTypes.MultiCallParams>(
    calls: Calls
  ): Promise<PrimaryRegistrarTypes.MultiCallResults<Calls>> {
    return (await multicallMethods(
      PrimaryRegistrar,
      this,
      calls,
      getContractByCodeHash
    )) as PrimaryRegistrarTypes.MultiCallResults<Calls>;
  }
}
